
1. ES5 var의 문제점 (1~3.html)

    - var는 중복 선언이 가능함
    - var는 블록 단위 변수가 아님(함수나 전역 단위만 지정 가능)
    - var는 호이스팅(끌어올림) 가능


2. 블록 단위의 let 등장 (4~5.html)

    - let은 중복선언 불가능
    - let은 블록 단위의 변수
    - let은 호이스팅 불가능


3. 상수를 정의하는 const 키워드

    - 상수를 정의 할 때는 선언과 동시에 초기화 필수
    - let과 동일하게 블록 단위의 변수, 호이스팅 지원하지 않음
    - const는 상수기 때문에 새로운 값을 할당할 수 없다.
    - const를 선언할 때 변수명은 대문자로 지정한다.


4. const 키워드와 객체

    - const로 객체를 선언했을 때 객체 안에 내용은 변경 가능함
    - 원시값인 변수는 재할당 없이는 변수 값을 변경할 수가 없음
    - 객체의 속성 값들은 재할당 없이도 직접 변경할 수 있음
    - const는 재할당을 금지하는 것이고 불변을 의미하지는 않음


5. ES6에서의 변수 선언

    - 기본적으로는 const를 이용해서 변수 선언하되 재할당이 필요한 변수는 let으로 선언
    - ES6에서는 var를 사용하지 않음
    - let 변수 선언 할 때는 최대한 단위를 작게 선언
    - 상수와 객체는 최대한 const로 선언 하도록 한다.


6. 템플릿 리터럴

    - 템플릿 리터럴은 ES6에서 도입된 새로운 문자열 표기법
    - 탬플릿 리터럴은 멀티라인 문자열, 표현식 삽입, 태그드 탬플릿을 지원(태그드 태그는 react때 배움)
    - 탬플릿 리터럴은 백틱(`)을 사용해서 선언
    - ${} 이용해서 선언된 변수를 문자열에 직접 사용가능


7. 지수 연산자 (14.html)

    - 거듭제곱을 계산해주는 연산자
    - ** 로 표시
    - Math.pow()함수와 동일한 기능


8. 논리 연산자를 이용한 단축평가 (15, 16.html)

    - &&, || 결과를 결정하는 값을 반환
    - 'cat' && 'dog' = 'dog' (cat은 T이기때문에 &&에서 dog가 결과를 결정하고 dog반환)
    - 'cat' || 'dog' = 'cat' (cant은 T이기 때문에 ||에서 cat이 결과를 결정하고 cat 반환)
    - true || anything = true
      false || anything = anything
      true && anything = anything
      false || anything = false


9. 객체에 추가된 기능들 (17.html)

    - 속성의 축약표현

        // ES5
        var obj = {
            x : 1,
            y : 2
        }

        //ES6
        let x = 1, y = 2;
        const obj = {x, y};

    - 계산된 프로퍼티 이름 (18.html)
      탬플릿 리터럴의 표현식 삽입 기능을 이용하여 동적으로 속성값을 만들어 줄 수 있다.

    - 메소드의 축약 표현 (19.html)


10. ES6에서 새로 도입된 class (20.html)

    - ES5에서는 객체의 상속을 하려면 무조건 프로토타입의 상속을 이용해야했음
    - 객체지향 언어에 익숙한 개발자들이 프로토타입 기반 개발에 어려움을 느껴
      ES6부터는 class가 도입됨
    - class를 사용한다고 프로토타입 기반을 포기하는 것은 아님
    - ES5의 객체 생성방식에 하나의 방식이 추가된 것이라고 생각하면 됨
    - 기존 객체 생성방식 보다 편하게 상속을 구현할 수 있다.(extends, super 키워드 사용가능)
    
    - class의 선언
      //생성자 함수는 항상 constructor로 만들어야 된다.

      class 객체명 {
            constructor(매개변수){
                초기화과정;
            }
            프로토타입 메소드 {

            }
            정적 메소드 {

            }
            get getter 메소드() {

            }
            set setter 메소드 () {

            }
      }

    - class에는 필드를 지정할 수 없음, 메소드만 선언 가능


11. class의 상속 (21.html)

    - extends 키워드 사용하여 상속받아 새로운 클래스를 정의
    - 생성함수를 상속받아서 동적으로 클래스를 만들 수 있다.


12. ES6의 화살표 함수 (23.html)

    - ES6 이전의 메소드들은 모두 호출 가능하면서 생성자 함수로 사용 가능
      그래서 모든 메소드들에 불필요하게 prototype 객체가 생성되는 경우가 발생
    - 호출 가능하지만 생성자 함수로는 사용 불가능한 화살표 함수가 등장
    - 화살표 메소드의 정의
      funtion 키워드 대신 => 키워드 사용
      
      //ES5
      funtion add(a, b) {
        return a + b;
      }

      //ES6 화살표 함수 1
      const add = (a, b) => {
        return a + b
      }

     //ES6 화살표 함수 2 
       (소괄호로 감싸면 소괄호 안의 내용 모두 리턴한다 라는뜻)
      const add = (a, b) => (
        a + b;
      )

     //ES6 화살표 함수 3 (매개변수 1개 일때)
     const print = a => {
        console.log(a);
     }

     //ES6 화살표 함수 4 (매개변수 없을때)
     const add = () = > {
        console.
     }


13. 화살표 함수와 일반 함수의 차이점 (23~27.html)

    - 화살표 함수는 생성자 함수로 사용 불가능
    - 화살표 함수는 prototype이 생성되지 않음
    - 중복된 매개변수 이름을 사용할 수 없음
    - 화살표 함수는 argument, this, super, new.target 바인딩을 갖지 않음


14. Rest 파라미터 (28.html)

    - ...키워드를 사용하여 함수에 전달된 매개변수 목록을 배열로 전달 받음


15. 매개변수의 기본 값 지정(29.html)

    - ES6에서는 함수를 정의할 때 매개변수의 기본값을 지정할 수 있음
      funtion add(a = 1, b = 1) {
        retrun a + b;
      }
    - 주의할 점 : Rest파라미터에는 기본 값을 지정할 수 없음


16. 배열의 고차원 함수 (30~32.html)

    - concat : 원본 배열의 마지막에 새로운 요소를 추가한 새로운 배열 반환

    - map : 배열의 요소를 하나씩 꺼내서 인수로 전달된 콜백함수를 반복 호출
            "콜백함수의 반환 값들로" 이루어진 새로운 배열 반환

    - filter : map과 동일하게 동작
               배열의 요소를 하나씩 꺼내서 인수로 전달된 콜백함수를 반복 호출
               "콜백함수의 반환 값이 true인 요소로만" 이루어진 새로운 배열 반환